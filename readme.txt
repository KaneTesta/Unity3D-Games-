Diamond Square Terrain Mesh:


	- Values are stored in:
	
	- Corners are initialised
	- Iteratively complete diamond and square steps until divisions threshold is met.
	- Collider is assigned using the mesh so that we don't go under the map

	- terrainVertColor[] stores Colors for each vertex
	- verts[] stores all the vertices
	- tris[] vertices are stored in groups of 3 to define the triangles which will be rendered
	- uvs[] each vertex needs a UV. The values represent fractional offsets into a texture. This allows us to map portions of a texture to specific triangles, EX having a triangle with a gradient of colours
	- landscape is the mesh that contains all of the above.

	- The triangles are inserted in a nested for loop. Vertex positions are set up here aswell. However, no vertical displacement is set up until further down.

	0,3------1
	-   \    - 
	-    \   -
	-     \  -
	5--------2, 4


	- The corner points are initialised first, and iterate Log2(divisions) times
	- We then undertake the diamond square stage on each square, working from the middle, then performing the diamond step and the square step.
	
	Diamond Step:
		- Set the midpoint to be the average of its 4 corners + random value between offset, being the public height field

	Square Step:
		- Set the midpoint of the diamond to be the average of 4 corners plus random value





Water Mesh:
	- Height of the mesh with the water is determined by the upper bound threshold of the RiverBank section. I had to normalise the vertices in the other terrain to find and perform calculations to return the exact y-value which the water mesh will be at.
	- Similar implementation to diamond square with the colour, triangle and vertices arrays, except there is no displacement in the vertices and the colour is constant.



Shaders/Colouring:

	- Colours are based on where about a vertice sits in a normalised scale of vertices based on the y-axis. I have set float values for each texture's upper bound, and this is used alongside a Color variable to set the colour of vertices. Since the space between two vertices are rather small, a fade between the colours from the phong shader weren't evident. To counter this I made functions called InterpolationPercentage and colCreator to calculate where abouts in a colour section a vertice lies, and fades the vertice color according to this position. For example, if a point is 50% in between the Snow Upper Bound, and Stone Lower Bound, the colour will be 50% between Snow and Stone.
	- The shaders were basically a cut and past from tutorials 4 & 5, however in the Water shader I did some research and discovered how to add transparency to the mesh. This included a property, Tag, ZWrite disabled and a Blend. I did this so you can see the depth of the water beneath
	- The waves are generated by the movement of sin waves.


Collision uses discrete collision

References:
FPS Display (https://forum.unity.com/threads/fps-counter.505495/)

Transparent Shader (https://learn.unity.com/tutorial/writing-your-first-shader-in-unity#5c7f8528edbc2a002053b570)

Diamond Square (https://en.wikipedia.org/wiki/Diamond-square_algorithm#Description, https://www.youtube.com/watch?v=1HV8GbFnCik&t=699s, https://www.youtube.com/watch?v=iG0Lpp0SQ7U&t=38s)
